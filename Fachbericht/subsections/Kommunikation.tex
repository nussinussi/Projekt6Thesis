\subsection{Kommunikation}\label{subsec: Kommunikation} \todo{anpassen}
\subsubsection{WLAN Konfiguration}\label{subsub: Wlan Konfiguration}
Die Funkkommunikation zwischen Sensor, Aktor und MQTT-Brocker wird mittels Wireless Local Area Network (WLAN) auf dem OSI layer 1 stattfinden. Um die einzelnen Target also Sensoren und Aktoren in das Lokale Netzwerk zu verbinden, wird beim Starten des ESP32 ein Accespoint eröffnet. Für diesen WiFi-Manager Prozess wird eine Bibliothek eingebunden. Die benötigte Bibliothek steht auf Github zur Verfügung \cite{zhouhan0126_zhouhan0126/wifimanager-esp32_2019}. 

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{graphics/statediagramWiFi.png}
	\caption{Statediagram Verbindungsaufbau ESP ins Netzwerk mit einem AP}
	\label{pic: statediagramWiFi}
\end{figure}   

Wird die Bibliothek WiFiManager.h eingebunden und initialisiert stehen verschiedene Funktionen zur Verfügung. Die Funktion autoConnect() eröffnet nach dem Start des ESP einen Access Point wenn keine Konfigurationsdaten im nichtflüchtigen Speicher vorhanden sind. Falls Konfigurationsdaten vorhanden sind werden sie aus dem EEPROM gelesen und es wird kein Access Point eröffnet. Sollen aber die Konfigurationen bei jedem Start durchgeführt werden, kann die Funktion startConfigPortal() aufgerufen werden.   

Der Acces Point kann bei bedarf auch passwortgeschützt verwendet werden. In diesem Versuch wird er ohne Passwort genutzt und ist somit mit einem Smartphone oder Notebook ersichtlich, siehe Abbildung \ref{pic: wifiNetz}. Wird kein Name zugewiesen, generiert der ESP selber ein Name mit ESP und Chip-ID.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{graphics/WifiNetz.png}
	\caption{Esp Acces Point}
	\label{pic: wifiNetz}
\end{figure} 
Sobald "verbinden" mit diesem Netzwerk gewählt wird, startet der Browser eine Konfigurationsseite mit der IP Adresse des Targets. Nun ist ein Menü ersichtlich mit folgenden Wahlmöglichkeiten, siehe Abbildung \ref{pic: wifiNetz}:

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{graphics/WifiHome.png}
	\caption{Esp Konfiguration Home Menu}
	\label{pic: wifiHome}
\end{figure}   

Wird 'Configure WiFi and MQTT' angewählt erscheint folgende Ansicht in Abbildung \ref{pic: wifiKonfig}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{graphics/WifiKonfig.png}
	\caption{Esp Konfiguration WiFi und MQTT}
	\label{pic: wifiKonfig}
\end{figure}   

Netzwerke, welche in der Umgebung gefunden wurden, werden angezeigt, die Parameter die zur WiFi Verbindung notwendig sind, können nun eingegeben werden. Im unteren Teil wird eine Voreinstellung der MQTT-Brocker-Adresse angezeigt und dessen Passwort, diese können beliebig geändert werden. Im WiFiManager Hauptmenü können die gleichen Konfigurationen ohne, dass nach vorhandenen Netzen gesucht wird, mit dem 'Configure WiFi(No Scan)' Button, gemacht werden. Mit dem Info Button werden Folgende Informationen angezeigt ChipID, Soft AP IP und Soft AP MAC wie auch Station AP MAC Adresse.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{graphics/MQTTSubPubClient.png}
	\caption{Esp Info}
	\label{pic: SubPubClient}
\end{figure}   

Die für die MQTT-Kommunikation wird die Libary PubSubClient.h eingebunden. Als erstes wird der WiFiClient initialisiert. 

Danach wird der PubSubClinet als Client instantiiert, für diesen Vorgang werden folgende Parameter benötigt:\\
\begin{itemize}
\item 	server: Adresse von MQTT-Server\\
\item 	port: der Port von dem MQTT-Server\\
\item 	client: eine Instanz vom Ethernet-Client.\\
\end{itemize}
Die Funktion publishSerialData() ermöglicht, eine Nachricht zu veröffentlichen, bei diesem Vorgang wird den Topic und die seriellen Daten veröffentlicht. Beim Aufruf dieser Funktion, wird jedes mal überprüft ob die Verbindung zum MQTT-Borcker in Ordnung ist. 

Ist die Verbindung nicht in Ordnung, wird sie mit der Funktion connect(), hergestellt. Um diesen Prozess erfolgreich durch zu führen werden, CliendID, MQTT-Benutzername und Passwort benötigt.

Ist die Verbindung in Ordnung werden die Daten mit dem Befehl publish() veröffentlicht \cite{noauthor_arduino_nodate-1}.

\subsection{Programmcode Sensorbord}
Die Aufgabe welcher der Mikrocontroller vom Sensorboard  übernehmen besteht darin, dass er Betätigungen der Touchtasten auf dem Frontprint erkennt. Jeder Touchtaster besitzt ein LED mit dem das Betätigen bestätigt wird. Diese Funktion wurde so initialisiert, damit der User eine sofortige Kenntnis über die ausgelöste Aktion bekommt. Mit dem Sensorboard wird auf dem Frontprint die Umgebungstemperatur gemessen.



\subsubsection{	Übersicht} 
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{graphics/StatemaschineSensor.png}
	\caption{In dieser Abbildung ist das Statediagram vom Sensorboard abgebildet}
	\label{pic: statemaschine sensor}
\end{figure} 

\newpage

\subsubsection{setup()}\label{subsubsec: sensor setup}
Wird der Mikrocontroller gestartet so werden als erstes Configurations-Daten im EEPROM gesucht. Werden keine Daten gefunden oder wird die Reset-taste betätigt wird ein Accespoint eröffnet und Confugurations Parameter können mittels Browser eingegeben werden. Dieser Vorgang wird im Kapitel Kommunikation genauer beschrieben. Als nächster Schritt werden für die MQTT-Messages die Topics anhand der Bordbezeichnung und der Anwendung generiert. Die Bordbezeichnung wird im Configportal eingegeben und im EEPROM abgespeichert, sie dient dazu, wenn mehrere Boards installiert werden um die empfangenen Nachrichten zu unterscheiden. Eine mögliche Topic für eine MQTT Nachricht wenn beispielsweise der erste Taster betätigt wird kann folgendermassen aussehen: "data/sesnorboard/wohnzimmer/S1" in diesem Fall wurde die Bordbezeichnung Wohnzimmer gewählt. 

\subsubsection{loop()} \label{subsubsec: sensorloop}
Im loop() wird als erstes die Funktion tread(), dann shine() aufgerufen, danach wird die Momentane Zeit mit der Funktion clock() geholt. In der Variabel count wird die Zeitdifferenz zwischen den wiederholenden Durchgängen von touch() addiert. Dies passiert solange bis der Wert x erreicht ist, in diesem Fall alle 10 Sekunden. Wenn der Wert x erreicht ist wird die Funktion tempf() aufgerufen, mit dieser wird mittels NTC die Temperatur gemessen. Im gleichen Zyklus wie die Temperaturmessungen Durchgeführt werden, wird die Staus LED geschaltet, so kann überprüft werden, ob sich das Bord im normalen Betrieb befindet, sprich der loop() wird gewiss komplett Durchlaufen. Die Funktionen sind in der nachfolgenden Abbildung abgebildet und werden anschliessend erläutert.

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{graphics/FunktionenSensor.png}
	\caption{In dieser Abbildung sind die Funktionen vom Sensorboard abgebildet}
	\label{pic: funktionen sensor}
\end{figure}   
\subsubsection{touch()} 
Wie in der Abbildung \ref{pic: statemaschine sensor} zu erkennen ist, wird die Funktion touch() nicht aufgerufen. Sie dient alleine zum debuggen also um den optimalen tresh Wert zu finden. Dieser Wert definiert ab wann die Touchsensoren als gedrückt erkannt werden. In der Funktion wird die Variabel waitTime initialisiert mit dem wert 250 weiter wird der Wert millis() in die Variable Time gesetzt. In einer for-wihle werden so lange Time modulo waitTime kleiner als 2 sind, sprich die ersten 2 Millisekunden von 250 Millisekunden, mit Serial.println() der aktuell eingelesene Touchwert ausgegeben. Dieser Wert befindet sich im Ruhezustand um 50-80, wenn eine entsprechende Touch-Taste betätigt wird sinkt dieser Wert auf 10-30.  
\subsubsection{shine()}
In der Funktion shine() wird in einer for-while der Eingelesene Wert das sogenannte taservalue der jeweiligen Touchtasten mit dem Tresholdwert, tresh verglichen. Ist das tastervalue kleiner als tresh, wird eine MQTT-Message mit der entsprechenden Topic und der Payloud "ON" published. Ebenso wird die Led der entsprechenden Taste HIGH gesetzt. Trifft der andere Fall zu, wenn das tastervalue grösser als tresh ist wird die entsprechende Led LOW gesetzt.
\subsubsection{tread()}
In der Funktion tread() werden in einer for-while die aktuellen Werte der vier Touch-Tasten eingelesen und in den int-array tastervalue gesetzt, um Ausreisser zu eliminieren, wird ein Mittelwert erstellt. Es werden jeweils 15 Messungen addiert und aschliessend durch die Anzahl Messungen dividiert.  
\subsubsection{tempf()}
In dieser Funktion wird die Temperatur mit dem NTC ermittelt. In einer for-wihle wird der Analogwert am NTC in die Variabel Untc gesetzt ebenso wird der gemessene Referenzwert am Spannungsteiler gemessen. Nach der Umwandlung vom eingelesenen Wert des ADCs in Volts mit der Formel \todo{referenz formel adc}, wird anschliessend der Wert des Widerstands aus dem Spannungsteiler berechnet \todo{(ref auf Formel)}. Der Wert des Widerstand wird mit der Formel \todo{formel} in Grad $°C$ umgerechnet. Der gesamte Vorgang wird 10 mal wiederholt, damit der Mittelwert ermittelt werden kann. Der berechnete Temperaturwert wird von float in ein char umgewandelt und mit MQTT published. 
\newpage
\subsection{Programmcode Aktorbord}
Die Aufgabe des Aktorbord besteht darin, dass Befehle empfangen, verarbeitet und ausgeführt werden. Es befinden sich vier Relais auf dem Bord,welche 230 Volt schalten können, diese werden mit Digitalen IO Pins angesteuert. Eine weitere Aufgabe ist die Ausgabe von zwei DC-Spannnugen 0-10 Volt. Die jeweilige Spannung entsteht durch ein PWM Signal. Eine letzte Aufgabe ist, 0-10 Volt einlesen. Das Eingangssignal gelangt über ein Spannungsteiler an den AD-Wandler. Der Mikrocontroller wertet das Signal aus und generiert eine MQTT-Message welche in einem Periodischen Zyklus publishd wird.    


\subsubsection{	Übersicht} 
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{graphics/StatemaschineAktor.png}
	\caption{In dieser Abbildung ist das Statediagram vom Aktorbord abgebildet}
	\label{pic: statemaschine Aktor}
\end{figure} 
\newpage

\subsubsection{setup()}
In der Abbildung ist zu erkennen, dass genau der gleiche Ablauf wie beim Sensorprint \ref{subsubsec: sensor setup} statt findet. Wird aber der Programm Code selber betrachtet werden andere Bezeichnungen wie andere Definitionen von pinMode() usw. im Bezug zum Sensorbord Festgestellt werden. 
\subsubsection{loop()}
Im loop() wird als erstes die Funktion clien.loop() aufgerufen. Diese Funktion ist im wesentlichen zuständig, dass MQTT Befehle empfangen und verarbeitet werden, Sie wird anschliessend ausführlich erläutert. In einem weiteren Schritt wird wie im loop() vom Sensorbord beschrieben \ref{subsubsec: sensorloop}, Periodischer Zyklus erstellt welche nur alle 10 Sekunden ausgeführt wird. In diesem Zyklus befindet sich die Funktion publishADC, welche die gemessenen Werte von den 0-10 Volt Eingenen als MQTT-Message published.
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{graphics/FunktionenAktor.png}
	\caption{In dieser Abbildung sind die Funktionen vom Sensorboard abgebildet}
	\label{pic: funktionen Aktor}
\end{figure}   
\subsubsection{client.loop()}
 Das Objekt \textit{client} wurde aus dem PubSubClient gebaut, wo der loop() implementiert wurde. Als erstes wird die Verbindung zum MQTT-Broker überprüft, dann bei bedarf die MQTT-Message empfangen und vorbereitet, dass sie in der Funktion callback()  genutzt werden kann. callback() wird aufgerufen.
 \subsubsection{callback()}
 In dieser Funktion wird als erstes der Inhalt von der Empfangenen Topic überprüft, fällt der Vergleich positiv aus wird der Inhalt der Payload überprüft. Die vier Verschiedenen Relais und die zwei Analogausgänge unterscheiden sich an Hand der Topic. Bei den Relais ist die Payload ON oder OFF und das Relais wie auch das Led des entsprechenden Relais wird in den geforderten zustand gesetzt. Trift die Topic auf ein Analog Ausgang wird nach Umwandlung der Payloud von einem String in ein Float, das PWM-Signal für den entsprechenden Ausgang gesetzt. Den Duty cycle für das PWM Signal wird berechnet indem die gewünschte Spannung voltage folgender Massen verrechnet wird : $(voltage/3.2 \cdot 4095)/3.25$. 3.2 sind es, weil die Verstärkung 3.2 beträgt und 3.25, weil das die Amplitude des PWM Signales ist. Leider kann die Amplitude abweichen und ist nicht sehr genau. Mehr zur Genauigkeit in der Validierung.
 
 \subsubsection{publishADC()}
Mit dieser Funktion werden die 0-10 Volt Eingänge ausgewertet und Resultate als MQTT-Message versendet. Der jeweiligen Messreihe am ADC wird der Mittelwert berechnet, welcher dann von einem float in ein char-Array umgewandelt wird. Als nächstes wird der char-Array und die entsprechende Topic vom PupsubClient veröffentlicht.


\newpage

\subsection{Programmcode Openhab}        
Der Aufbau des Systems besteht aus verschiedenen Komponenten welche in nachfolgender Tabelle aufgelistet sind
\begin{table}[H]
	\begin{tabular}{|l|l|}
		\hline 
		Bezeichnung	& Beschreibung \\ 
		\hline 
		Bindings	& Schnittstellen verknüpft verschiedene Dienste miteinander  \\ 
		\hline 
		Things	& Definition von Gerät, Verbraucher, Teilnehmer des Systems  \\ 
		\hline 
		Channel	& Verbindung zwischen Thing und Item  \\ 
		\hline 
		Item	& Repräsentiert Informationen des Gerätes, Schalter, Label usw. \\ 
		\hline 
		Rules	& Festgelegte Regeln für automatische Abläufe\\ 
		\hline 
		Sitmaps	& Benutzeroberfläche, präsentiert Informationen  \\ 
		\hline 
	\end{tabular} 
	\caption{Komponenten Openhab Software \cite{noauthor_introduction_nodate-1}}
	\label{tab: Komponenten Openhab Software}
\end{table}
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{graphics/Openhabian.png}
	\caption{Komponenten und Verbindungen von Openhab}
	\label{pic: Komponenten Openhab}
\end{figure}   

\subsubsection{Bindings}
Als Schnittstelle von den Items zu den Things wird ein MQTT-Broker benötigt. Um die Systemzuverlässigkeit zu steigern wurde ein eigener Broker Installiert, so kann die Kommunikation auch ohne Netzwerkanschluss ans Öffentliche Netz funktionieren. Ein weiterer Vorteil ist die Sicherheit, es kann auf Passwörter verzichtet werden, da kein Zugriff von ausserhalb des Home-Netzwerk möglich ist.

\subsubsection{Things}
 Als Geräte wurden drei Komponenten hinzugefügt, welche in der Abbildung \ref{pic: Komponenten Openhab} zu erkennen sind. Zum Aktor Thing gelangen im ganzen 8 Channels, um die Relais einzeln anzusprechen wurde pro Relais eine MQTT-Topic erstellt welche je einen Channel verfügt und so mit je einem Item verbunden. Zwei Channel sind für die 0-10 Volt Eingänge und zwei weiter Channel für die 0-10 Volt Ausgänge. Das Sensor Thing verfügt 5 Channel jeder Taster einzeln und ein Channel für die Temperaturmessung.

\subsubsection{Channel}
Die Channes sind die Verbindungen von den Geräten zu den Items also den Software-Zustände, in diesem Projekt werden alle möglichen Fähigkeiten der Geräte genutzt und mit einem Channel gebunden.

\subsubsection{Item}
Das Item zeigt den Status des Verbrauchers oder den gemessenen Wert eines Sensors an. Items werden verwendet wenn Regeln definiert werden,ebenso sind sie mit den Channels verlinkt und können einzeln oder als Gruppen auf dem Sitmap genutzt werden. Als anwendung eines Icons können verschiedene Typen gewählt werden. In diesm Projekt wird in erste Linie der normale Switch verweden welcher in den Zustand ON oder OFF geschalten wird. Für die 0-10 Volt ausgänge werden Dimmer verwendet die als Slider in der Sitmap angezeigt wird und Sie generieren je nach Position einen Wert zwischen 0-1. Um die Messwerte an den 0-10 Volt Eingängen zu verwenden werden die Items als Number genutzt.

\subsubsection{Rules} 
Automatische Prozesse werden mit i Rules definiert. Um das System Benutzerfreundlicher zu Gestalten werden in den Rules die Befehle der Taster verarbeitet und die Entsprechenden Befehle an die Relais generiert. So kann gewährleistet werden, dass der Kunde selber keine Änderungen an den Aktoren und Sensoren selber vornehmen muss. Die Rule Syntax basiert auf Xbase \cite{noauthor_xtext_nodate}. Um die Aufgeben der Befehls Weiterleitung zu übernehmen bestehen die Ruls im wesentlichen aus when und then. In diesem Fall sind sie im Teil when, auf den Empfang des jeweiligen Update getriggert. Somit wird mit einem Update des Status der Teil then ausgelöst, wo sich eine if Bedingung befinden. In diese Bedingung wird der Stus überprüft      

\subsubsection{Sitmaps} 

 
   
\subsubsection{Lizenzen} \todo{anpassen auf github min 1 ganze Seite, veröffentlichen usw}
Die Bibliotheken welche in den Kapiteln \ref{subsub: Wlan Konfiguration} , \ref{subsec: Framework} erwähnt wurden, sind freie Softwarepakete und können unter der Bedingung der GNU Lesser General Public Lizenz (LGPL) geändert werden. Die LGPL gibt die Freiheit das Programm, für jeden Zweck auszuführen, anzupassen und die Änderungen zu veröffentlichen. \cite{noauthor_gnu.org_nodate}.


 
